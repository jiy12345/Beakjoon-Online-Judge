#include<iostream>
#include<algorithm>
using namespace std;

/*
1. 문제 분석
- 변수
 N: 버튼을 누르는 횟수

- 변수 제한 사항
 N: 1 ~ 100


- 문제 상황
 크리보드에 다음과 같은 4가지 버튼만 있다고 할 때,

화면에 A를 출력한다.
Ctrl-A: 화면을 전체 선택한다
Ctrl-C: 전체 선택한 내용을 버퍼에 복사한다
Ctrl-V: 버퍼가 비어있지 않은 경우에는 화면에 출력된 문자열의 바로 뒤에 버퍼의 내용을 붙여넣는다.

 크리보드의 버튼을 총 N번 눌러서 화면에 출력된 A 개수의 최대값을 구하여라!

2. 풀이 계획

기능별로 어떻게 구현할 수 있을 지 고민해보자

1. 화면에 A를 출력한다.
dp[i] = dp[i] + 1;

2 + 3. 화면 전체 선택 -> 버퍼에 복사
buffer[i] = dp[i - 2];
 => 이 경우 최대값이 아닌 경우가 발생할 수 있을까?
 => 그렇지 않다. dp[i]는 항상 최대값으로 유지되도록 할 것이기 때문에, 항상 최대값이고, 따라서 복사하는데 활용하면 된다!

4. 버퍼의 내용 붙여넣기
dp[i] = buffer[i];


위처럼 복잡하게 생각하면 안된다. 위처럼 복잡하게 생각되는 순간, 이미 고려하지 못한 문제점이 있을 수 있다는 것이고, 따라서 에러가 발생할 확률이 매우 높다!

그렇다면 각 위치에서의 최대값은 어떻게 될까?

첫 7번까지는 각 위치에서의 최대값이 1번 버튼을 누른 것이지만, 그 이후로는 1번 버튼은 의미가 없어진다.



3. 계획 검증
 1. 알고리즘 측면

 2. 시간복잡도 측면

 3. 공간복잡도 측면
*/

#define MAX 101

long long dp[MAX];

int N;

long long solution() {
	// 6번까지는 그냥 입력이 최대값!
	for (int i = 1; i <= 6; i++)
		dp[i] = i;

	for (int i = 7; i <= N; i++)
		for (int j = 3; i - j > 0; j++) 
			dp[i] = max(dp[i], (j - 1) * dp[i - j]);

	return dp[N];
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL); cout.tie(NULL);

	cin >> N;

	cout << solution();
}