#include<iostream>
using namespace std;

/*
1. 문제 분석
- 변수
 n: 포도주 잔의 개수

- 변수 제한 사항
 N: 1~10,000
 포도주의 양: 정수/0~1,000

- 문제 상황
 포도주 시식에 다음과 같은 규칙이 있을 때,

1. 포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다.
2. 연속으로 놓여 있는 3잔을 모두 마실 수는 없다.

최대로 마실 수 잇는 포도주의 양을 출력한다!

2. 풀이 계획
각 위치의 최대값이 전체 최대값을 구하는 데 의미가 유효한 상태로 남아있으므로, 다이나믹 프로그래밍을 사용할 수 있다!

점화식을 세운다면

1항: 1항 그대로
2항: 2항과 1항의 합
3항: 3항과 max(1항, 2항)의 합

n항: n항과 max(n-1항 + n-3항까지의 최대값, n-2항까지의 최대값) 


3. 계획 검증
각각이 최대값을 유지하고 있는가, 규칙을 어기고 있지는 않은가를 봐야함!

허점이 있을거라고 예상을 하긴 했는데 실제로 허점이 발생하였다!
처음에는 현재 잔을 마시는 경우만 포함하여 비교하였는데, 이렇게 될 경우 고려하지 못하는 경우의 수가 발생하게 된다!

현재잔을 마시지 말아야만 하는 경우에는 최대값을 제대로 고려하지 못하게 되는 것이다!

*/

// 각 잔의 와인 양을 저장할 배열
int amount_of_wine[10000] = { 0, };
// 각 항까지의 최대값을 저장할 배열
int dp[10000] = { 0, };

int n;

int solution() {
	// 첫 잔까지의 최대값: 첫잔의 양 그대로
	dp[0] = amount_of_wine[0];
	// 두번째 잔까지의 최대값: 첫째 잔의 양 + 두번째 잔의 양
	dp[1] = amount_of_wine[0] + amount_of_wine[1];
	// 세번째 잔까지의 최대값: 
	dp[2] = max(dp[1], amount_of_wine[2] + max(amount_of_wine[0], amount_of_wine[1]));

	for (int i = 3; i < n; i++) {
		// 점화식: 
		dp[i] = max(dp[i - 1], amount_of_wine[i] + max(dp[i - 2], amount_of_wine[i - 1] + dp[i - 3]));
	}
	// 마지막 잔을 먹지 않는 것이 최대값일 수 있으므로!
	return max(dp[n - 1], dp[n - 2]);
}


int main() {
	cin >> n;

	for (int i = 0; i < n; i++) {
		cin >> amount_of_wine[i];
	}

	cout << solution();
}
