#include<iostream>
#include<numeric>
using namespace std;

/*
1. 문제 분석
- 변수
 N: 오르막 수의 길이

- 변수 제한 사항
 N: 1~1,000

- 문제 상황
오르막수는 수의 자리가 오름차순을 이루며 인접한 수가 같을 수도 있는 수라고 한다.

오르막수의 길이 N이 주어졌을 때, 가능한 오르막 수의 개수를 구하여라.

=> 이때, 수는 0으로 시작할 수 있다!

2. 풀이 계획
수식을 세우기 쉽게 하도록, 전체 문제를 살짝 수정하였다!
 - 전체 문제: 끝나는 수가 n인(0 <= n <= 9) N길이의 오르막 수를 만드는 경우의 수 구하기
 - 부분 문제:  끝나는 수가 n인(0 <= n <= 9) k(1 <= k < N)길이의 오르막 수를 만드는 경우의 수 구하기

 이렇게 모두 구한 후, N길이의 오르막 수 경우의 수들을 모두 합하면 답이 된다!

끝나는 수가 n인 k길이의 오르막 수의 경우의 수는 k-1 길이의 오르막 수 중 끝나는 수가 0~n인 경우의 수를 모두 합한 것과 같다!

 따라서 점화식으로 써보면 다음과 같다.

 dp[n][k] = dp[0][k-1] + dp[1][k-1] + ... + dp[n][k-1] 

 이렇게 각 단계의 모든 n(0~9)에 대해 경우의 수를 구하고, 마지막에는 모든 n에 대한 경우의 수를 합하여 구한다!

3. 계획 검증


*/

// dp[i][j]: j로 끝나는 i길이 오르막 수의 경우의 수
int dp[1000][10] = { {0, } };

int N;

int solution() {
	// 각각의 첫 위치는 하나의 경우의 수만 가짐
	for (int i = 0; i < 10; i++) {
		dp[0][i] = 1;
	}

	for (int i = 1; i < N; i++) {
		for (int j = 0; j < 10; j++) {
			dp[i][j] = accumulate(dp[i - 1], dp[i - 1] + j + 1, 0) % 10007;
			// cout << dp[i][j] << " ";
		}
	}

	return accumulate(dp[N - 1], dp[N - 1] + 10, 0) % 10007;
}


int main() {

	cin >> N;

	cout << solution();
	
	return 0;
}
