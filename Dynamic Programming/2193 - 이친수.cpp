#include<iostream>
using namespace std;

/*
1. 문제 분석
- 변수
 N: 이친수의 자리수

- 변수 제한 사항
 N: 1~90

- 문제 상황
 이진수 중 다음과 같은 성질을 가진 것을 이친수라 할 때
 
 1. 이친수는 0으로 시작하지 않는다.
 2. 이친수에서는 1이 두 번 연속으로 나타나지 않는다. 즉, 11을 부분 문자열로 갖지 않는다.

 N이 주어질 때 N자리 이친수를 구하여라

2. 풀이 계획
 - 전체 문제: N자리 이친수의 개수 구하기
 - 부분 문제: n자리 이친수의 개수 구하기 (n = 1~N)

 각 위치에서의 이친수의 개수는 현재 위치가 0일 때와 1일 때의 경우의 수를 모두 합한 것이다.
 
 - 현재 수가 0: 이전 수는 0과 1이 모두 될 수 있으므로, 이전 자리수 까지의 이친수의 개수를 더하면된다.
 - 현재 수가 1: 이전 수는 반드시 0이어야 하므로, 두 자리 전까지의 이친수의 개수를 더하면 된다.

 따라서 점화식으로 써보면 다음과 같다.

 dp[n] = dp[n-1] + dp[n-2]
  

3. 계획 검증
각각이 최대값을 유지하고 있는가, 규칙을 어기고 있지는 않은가를 봐야함!

허점이 있을거라고 예상을 하긴 했는데 실제로 허점이 발생하였다!
처음에는 현재 잔을 마시는 경우만 포함하여 비교하였는데, 이렇게 될 경우 고려하지 못하는 경우의 수가 발생하게 된다!

현재잔을 마시지 말아야만 하는 경우에는 최대값을 제대로 고려하지 못하게 되는 것이다!

*/

// 각 항까지의 최대값을 저장할 배열
long long dp[90] = { 0, };

int N;

long long solution() {
	dp[0] = 1;
	dp[1] = 1;

	for (int i = 2; i < N; i++) {
		// 점화식: Fn = Fn-1 + Fn-2 (n ≥ 2)
		dp[i] = dp[i - 1] + dp[i - 2];
	}

	return dp[N - 1];
}


int main() {
	cin >> N;

	cout << solution();
}
