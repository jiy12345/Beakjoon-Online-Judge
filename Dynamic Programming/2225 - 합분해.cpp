#include<iostream>
#include<numeric>
using namespace std;

/*
1. 문제 분석
- 변수
N: 정수의 범위, 정수의 경우의 수 
K: 정수의 개수

- 변수 제한 사항
N: 1~200
K: 1~200

- 문제 상황
0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램을 작성하시오.

덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우)
또한 한 개의 수를 여러 번 쓸 수도 있다.

2. 풀이 계획
각 위치를 선택하느냐, 선택하지 않느냐에 따라 수열이 달라질 수 있다!
그리고 각 위치까지의 최장 증가 부분 수열의 크기는 항상 같으므로, 현 위치보다 다음 수가 작은 수만 아니라면 문제없이 적용이 가능하다!

따라서 자세한 계획은 다음과 같다.


dp[N][K] = dp[N-0][K-1] + dp[N-1][K-1] + dp[N-2][K-1] + ... + dp[N-N][K-1]

이때, dp[0][K]는 모든 수가 0인 합이므로, 경우의 수는 하나밖에 없다!

이때, dp[N][1]은 N 자기 자신하나로만 나타낼 수 있으므로 1이다! 
*/


long long dp[201][201];

int N, K;

long long solution() {

	// 초기화
	for (int i = 0;i <= N;i++) {
		dp[1][i] = 1;
	}
	for (int i = 0;i <= K;i++) {
		dp[i][0] = 1;
	}

	for (int i = 1;i <= K;i++) {
		dp[i][1] = (dp[i - 1][0] + dp[i - 1][1]) % 1000000000;
		for (int j = 2;j <= N;j++) {
			dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % 1000000000;
		}
		//for (int i = 0;i <= K;i++) {
		//	for (int j = 0;j < N;j++) {
		//		cout << dp[i][j] << " ";
		//	}
		//	cout << "\n";
		//}
		//cout << "\n";
	}
	
	return dp[K][N] % 1000000000;
}

int main() {
	cin >> N >> K;

	cout << solution();
}