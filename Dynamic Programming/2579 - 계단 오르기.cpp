#include<iostream>
using namespace std;

/*
1. 문제 분석
- 변수

- 변수 제한 사항
계단의 개수: 1~300
계단에 쓰여진 점수: 1~10,000

- 문제 상황
계단의 개수와 각 계단을 밟았을 때의 점수가 주어지고,

다음의 규칙에 따라

1. 계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.
2. 연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다.
3. 마지막 도착 계단은 반드시 밟아야 한다.

계단을 밟아야 한다고 할 때, 얻을 수 있는 총 점수의 최대값을 구하여라

2. 풀이 계획

재귀적으로 구현하되 각 위치에서 한계단을 올라왔냐, 두 계단을 올라왔냐에 따른 최대값을 각각 저장해놓으면 될듯 하다!
한계단 올라온 것에 대한 계산을 할 때는 두 계단을 올라온 것의 최대값만 사용해야 하며,
두계단을 올라온 것에 대한 계산을 할 때는 두 계단을 올라왔을 때와 한 계단을 올라왔을 때 중 최대값을 사용하면 될 듯 하다!

따라서 자세한 계획은 다음과 같다.
1. 배열에 각 계단의 점수를 입력받는다.
2. BFS로 N번째 계단부터 규칙에 따라 각 계단을 밟았을 때의 최대값을 저장하고, 반환한다!.
 => 이 때 해당 위치에 어떻게 올라왔느냐에 따라 다른 최대값을 저장한다!
*/

// 각 위치에 어떤 방식으로 왔느냐에 따라 정해진 최대값
// 0: 한계단 오르기, 1: 두계단 오르기
int max_nums[300][2] = { {0, } };
// 값을 입력받을 배열
int stair_point[300] = { 0, };

int N; // 계단의 개수

// n: 현재 계단 
// one_or_two: 이전 계단에서 올라올 때 어떤 방법을 선택해야 하는지
int solution(int n, int one_or_two) {
	// 이미 계산된 최대값이 있을 경우 그대로 반환
	if (max_nums[n][one_or_two] != 0) {
		return max_nums[n][one_or_two];
	}
	else {
		if (one_or_two == 0) { // 1계단 올라온 경우
			// 반드시 이전 계단에서는 두계단을 올라오는 방법을 선택해야 함
			max_nums[n][0] = solution(n - 1, 1) + stair_point[n];
			return max_nums[n][0];
		}
		else { // 2계단 올라온 경우
			// 이전 계단에서는 한계단 올라오거나 두계단 올라오는 방법중 하나를 선택 가능!
			max_nums[n][1] = max(solution(n - 2, 0), solution(n - 2, 1)) + stair_point[n];
			return max_nums[n][1];
		}
	}
}

int main() {

	cin >> N;

	for (int i = 0;i < N;i++) {
		cin >> stair_point[i];
	}

	// 첫 위치와 두번째 위치의 값 저장
	// 첫 위치는 그대로 첫 위치의 점수
	max_nums[0][0] = stair_point[0]; 
	max_nums[0][1] = stair_point[0];
	// 두번째 위치에서는 방법에 따라 점수가 달라짐
	max_nums[1][0] = stair_point[0] + stair_point[1];
	max_nums[1][1] = stair_point[1];

	// 마지막 위치에 어떻게 왔느냐에 따라 다른 값 저장 후 그 중 더 큰값 선택
	cout << max(solution(N - 1, 0), solution(N - 1, 1));
}