#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

/*
1. 문제 분석
- 변수
 T: 테스트 케이스의 개수
 n: 스티커의 열 길이

- 변수 제한 사항
 n: 1~100,000

- 문제 상황
 스티커가 2행 n열로 배치되어 있고, 뗀 스티커의 왼쪽, 오른쪽, 위, 아래에 있는 스티커는 모두 사용할 수 없게된다고 할때, 스티커를 떼서 얻을 수 있는 최고점을 구하여라

2. 풀이 계획
 - 전체 문제: 2행 n열의 스티커를 뗐을 때 얻을 수 있는 최고의 점수
 - 부분 문제: 2행 k열(1 <= k < N)의 뗐을 때 얻을 수 있는 최고의 점수

 각 위치 k 에서의 값의 최대값이 될 수 있는 후보는 다음과 같다!
 
1. 위치 k에서 위쪽 스티커를 선택할 경우
 1) k-1 위치의 아래쪽 스티커를 선택할 경우: 현 위치의 위쪽 스티커의 값에 k-1위치에서 아래쪽을 선택했을 때의 최대값을 더하면 된다!
 2) k-2 위치의 아래쪽 스티커를 선택할 경우: 현 위치의 위쪽 스티커의 값에 k-2위치에서 아래쪽을 선택했을 때의 최대값을 더하면 된다!
: 
2. 위치 k에서 아래쪽 스티커를 선택할 경우
 1) k-1 위치의 위쪽 스티커를 선택할 경우: 현 위치의 아래쪽 스티커의 값에 k-1위치에서 위쪽을 선택했을 때의 최대값을 더하면 된다!
 2) k-2 위치의 위쪽 스티커를 선택할 경우: 현 위치의 아래쪽 스티커의 값에 k-2위치에서 위쪽을 선택했을 때의 최대값을 더하면 된다!

1번과 2번은 n 이전의 k 위치들에서는 모두 따로 저장하며, 마지막에 n위치에서의 값을 출력할 시에만 두 위치간의 비교를 통한 최대값을 도출한다!

3. 계획 검증
*/

int sticker[2][100000] = { {0, } };

// dp[i][j]: j열의 i(0:위, 1:아래)행 스티커를 선택했을 때의 최대값
int dp[2][100000] = { {0, } };

// 테스트 케이스의 개수
int T = 0;

// 열의 길이
int n;

int solution() {
	dp[0][0] = sticker[0][0];
	dp[1][0] = sticker[1][0];
	dp[0][1] = sticker[0][1] + sticker[1][0];
	dp[1][1] = sticker[1][1] + sticker[0][0];

	for (int i = 2;i < n;i++) {
		dp[0][i] = sticker[0][i] + max(dp[1][i - 1], dp[1][i - 2]);
		dp[1][i] = sticker[1][i] + max(dp[0][i - 1], dp[0][i - 2]);
	}

	return max(dp[0][n - 1], dp[1][n - 1]);
}


int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);

	cin >> T;

	for (int i = 0;i < T;i++) {
		cin >> n;
		for (int j = 0;j < 2;j++) {
			for (int k = 0;k < n;k++) {
				cin >> sticker[j][k];
			}
		}
		cout << solution() << '\n';
	}
}