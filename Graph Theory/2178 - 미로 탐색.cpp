#include<iostream>
#include<vector>
#include<utility>
#include<queue>
#include<string>
using namespace std;

/*
1. 문제 분석

- 변수
N, M: 미로의 가로, 세로크기

- 변수 제한 사항
N, M: 2~100

- 문제 상황
(1, 1)에서 출발하여 (N,M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하라!

2. 풀이 계획
각각의 수들이 붙여서 주어지므로, 미로의 입력은 문자열로 받아야 처리가 쉬울 것 같다!
예외 처리를 줄이기 위해, 사방향의 끝 줄에 0들을 붙이도록 하자! => 이렇게 되면 배열에서의 인덱스도 (1, 1) => (N, M)이 된다!

DFS로 구현하면 시간초과가 발생할 수밖에 없다!
 => 따라서 BFS로 구현해야한다!

BFS로 구현한다면, 같은 깊이라는 것을 어떻게 나타낼까?


1. DFS로 구현
 => 시간 초과 발생
 시간복잡도 계산해보기

2. bfs로 구현
 => 어떻게 최소값을 표현할 지 어려움 겪음
 => 같은 깊이(거리)를 간 것 끼리 같이 따지므로, 가장 먼저 도착할 때 거리가 최단 경로임!
 => 따라서 큐에 푸시할 때 깊이(거리) 정보까지 같이 푸시하기!

3. 메모리 초과 발생
 => 질문을 검색하다가 알게 된 사실: 큐에서 팝 할때 방문했다는 표시를 했었는데, 이렇게 되면 팝 하기 전에 중복 방문하는 경로가 매우 많이 생기게 된다!

dfs를 사용해서 최단경로를 찾으려하면 지수시간이 걸린다고 알고있습니다. (모든 경로를 다찾아야하고, 지금 찾은 경로보다 나중에 찾은 경로보다 더 돌아가고 시간이 오래걸릴수 있으므로 다 탐색을 해줘야하니)

저는 가중치가 동일한 그래프에서 최단 경로(최단 시간 포함) 문제는 bfs를 사용하고 있습니다.


최단 거리 문제는 DFS로 할 수 없습니다. 각 칸에 처음으로 도달한 순간이 가장 빠르게 도달한 경로라는 보장이 없기 때문에 매번 재방문을 해야 하는데, 이것이 반복되면 시간 복잡도가 지수 형태가 되어 너무 오래 걸리게 됩니다.


DFS와 같이 완전 탐색을 하는 기법의 경우 일반적으로 지수 시간 복잡도가 걸립니다. 지수 복잡도라는 것은 일반적으로 어마어마하게 큰 복잡도이므로, 입력이 매우 작은 경우가 아니면 사용할 수 없다고 보시면 됩니다.

예를 들어, 매 칸마다 방문할 수 있는 다음 상태가 2개씩만 되더라도, 그 깊이가 100회만 될 수 있더라도 2^100이라는 수가 나오고 이 수는 연산이 아무리 빠르더라도 우주가 멸망할 때까지 다 계산을 할 수 없을 정도로 큰 수입니다. 칸이 100*100칸이라면 2^10000이 될 것이고, 이는 더더욱 절대 가능할 수가 없는 수치가 됩니다.

시간 복잡도의 개념에 대해 공부해 보시고, n, nlogn, n^2, 2^n, 3^n 등이 얼마나 빠르게 커지는 수인지 직접 계산해서 비교해보시면 그 차이를 느끼실 수 있을 것입니다. 일반적으로 컴퓨터는 1초에 10억 회 정도의 연산을 할 수 있는 것으로 보고, 시간 제한과 시간 복잡도에서 계산된 수가 어느 정도인지 대략적인 비교를 통해 코드가 얼마나 많은 시간이 걸릴지 대략적으로 예측할 수 있습니다.

3. 계획 검증


*/
int N, M;

vector<string> maze;

//         down,right,up,left 
int di[4] = { 0, +1, 0, -1 };
int dj[4] = { +1, 0, -1, 0 };

int answer = 2000; // 모든 칸을 방문하여도 1000


int solution(int start_i, int start_j) {
	queue<vector<int>> bfs_queue; // 방문할 좌표와 그 깊이를 같이 가지고 있는 큐
	
	bfs_queue.push({ start_i, start_j, 1 }); // 첫 좌표 푸시

	maze[start_i][start_j] = '0'; // 현재노드 방문했다는 표시하기

	while (!bfs_queue.empty()) {

		vector<int> cur_node = bfs_queue.front();
		bfs_queue.pop();
		int cur_i = cur_node[0];
		int cur_j = cur_node[1];
		int cur_depth = cur_node[2];

		if (cur_i == N && cur_j == M) {
			return cur_depth;
		}

		// 위, 아래, 왼쪽, 오른쪽 탐색
		// 갈 수 있는 방향인 1이 있는 방향으로만 탐색
		// 아래쪽

		for (int i = 0; i < 4; i++) {
			if (maze[cur_i + di[i]][cur_j + dj[i]] == '1') {
				maze[cur_i + di[i]][cur_j + dj[i]] = '0'; // 중복 방문 방지를 위해 미리 방문 표시하기
				bfs_queue.push({ cur_i + di[i], cur_j + dj[i], cur_depth + 1 });
			}
		}
	}
	return 0;
}

int main() {

	cin >> N >> M;

	string maze_row; // 미로의 각 한 행을 만들기

	string wall = ""; // 위와 아래 벽 만들기
	for (int i = 0; i < M + 2; i++) {
		wall += "0";
	}

	maze.push_back(wall); // 미로의 위 벽 표시

	for (int i = 0; i < N; i++) {
		cin >> maze_row;
		maze.push_back("0" + maze_row + "0"); // 왼쪽과 오른쪽 벽을 붙여서 입력
	}

	maze.push_back(wall); // 미로의 아래쪽 벽 표시

	// 벽을 위치시켰으므로 (0, 0)이 아닌 (1, 1) 위치부터 시작
	// 지나간 칸 수를 세는 것이므로 현재 칸도 포함시켜 1부터 시작
	cout<< solution(1, 1);

	return 0;
}