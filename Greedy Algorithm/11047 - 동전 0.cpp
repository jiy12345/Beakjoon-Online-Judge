#include<iostream>
using namespace std;

/*
1. 문제 분석

 - 변수
 N: 동전의 종류
 K: 나타내야 하는 총 가치
 Ai: 각 동전의 가치. A1은 가장 작은 동전의 가치이며, i값이 커질 수록 더 큰 단위이다.

 - 변수, 값에 대한 제한
 1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000
 1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수

 - 문제 상황
N개 종류의 동전이 주어졌을 때, 가치의 합을 K로 만드는 데 필요한 동전의 개수의 최솟값을 구한다.

2. 풀이 계획
문제 조건 중 가장 중요한 조건은 바로 Ai는 Ai-1의 배수라는 것이다. 이러한 조건 때문에 더 작은 단위의 동전으로 나타낼 수 있는 다른 경우의 수가 사라지게 된다.

따라서 가장 큰 단위의 동전을 먼저 선택하는 그리디 알고리즘을 떠올릴 수 있다.

따라서 전체 과정을 자세히 표현하면 다음과 같다.


1. 들어온 단위들을 배열에 받는다.
2. 반복문을 돌리며, 가장 큰 단위부터 시작하여 K를 나누고,
 1) 나눈 몫은 필요한 동전의 개수에 더하며,
 2) 나눈 나머지는 K에 다시 저장한다.


3. 계획 검증
위의 풀이 계획은 그리디 알고리즘을 선택하였으므로, 이 문제에 대한 그리디 알고리즘의 정당성만 증명된다면 계획이 검증되는 것으로 볼 수 있다.

그리디 알고리즘의 정당성을 증명하자면,

1) 탐욕적 선택속성 증명
1. 현재 선택할 수 있는 가장 큰 단위의 동전이 아닌 그보다 작은 단위의 동전을 선택한 최적해가 존재함을 가정한다.
2.더 큰 단위의 동전은 항상 더 작은 단위의 동전의 배수이므로, 2개 이상의 더 작은 동전은 무조건 더 큰 단위의 동전을 포함하여 더 적은 수의 동전을 사용하여 나타낼 수 있다.
3. 따라서 현재 선택할 수 있는 가장 큰 단위의 동전을 선택하지 않으면 최적해를 도출할 수 없다.
4. 따라서 현재 선택할 수 있는 가장 큰단위의 동전을 선택하는 것만이 최적해를 도출할 수 있다.

2) 최적 부분구조 증명
첫 번째 단위의 동전을 선택 후 나머지 단위를 선택하는 부분문제가 남는데, 이 때 또한 동전의 개수를 최소하한다는 같은 기준을 적용하면 전체에도 최적의 결과를 가져오므로 최적 부분구조는 자명하게 성립한다.

*/

int get_min_coin(int N, int K, int* coin_unit) {
	int min_coin = 0;

	// 2. 반복문을 돌리며 큰 단위부터 작은 단위 순으로 K를 나누기
	for (int i = N - 1; i >= 0; i--) {
		// 나눈 몫은 동전의 개수에 더하기
		min_coin += K / coin_unit[i];
		// 나눈 나머지 K에 저장
		K %= coin_unit[i];
	}
	return min_coin;
}

int main() {
	int N; // 동전의 종류
	int K; // 나타내야 하는 총 가치


	cin >> N >> K;

	int *coin_unit = new int[N];

	// 들어온 단위들 배열에 받기
	for (int i = 0; i < N; i++) {
		cin >> coin_unit[i];
	}

	int min_coin = get_min_coin(N, K, coin_unit);

	cout << min_coin;

	return 0;
}