#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

/*
1. 문제 분석

 - 변수
N: ATM에 줄 서있는 사람의 명수
Pi: i번째 사람이 돈을 인출하는데 걸리는 시간.

 - 문제 상황
각각의 사람에게는 번호가 매겨져있으며, 
각 사람이 가진 번호를 i라 할 때 Pi는 각 사람이 기다리는 시간을 제외한 순수하게 인출하는 데만 걸리는 시간이다.

따라서 각 사람이 인출하는데까지 걸리는 시간을 포함하여 계산하면 
자신보다 앞 순서에 있있는 사람들의 인출 시간과 자신의 인출시간을 더하여 계산한다.

이 때, 모든 사람들이 인출하는 데까지 걸리는 시간을 모두 합한 시간의 최솟값을 구하는 프로그램을 작성하라.

2. 풀이 계획
쉽게 생각해보면, 인출하는데 걸리는 시간이 앞에 온다면 좀 더 많은 사람들의 대기 시간이 길어질 것이다.
따라서, 시간이 오래 걸리는 사람을 최대한 뒤로 보내는 방법을 써야 한다.

이 경우 현재 남은 사람 중 인출에 걸리는 시간이 가장 적은 사람을 먼저 선택하는 그리디 알고리즘을 생각할 수 있다.

이를 구현하기 위해서는 걸리는 값을 작은 값부터 큰 값 순으로 정렬하여 값을 계산하면 답을 구할 수 있을 것이다.

다음과 같은 과정을 거치자

1. 들어온 값들을 벡터에 받는다.
2. 정렬함수를 통해 정렬한다.
3. 0부터 배열의 길이-1 까지 반복문을 돌리며 합을 저장할 변수에 (현재 위치의 원소) * (배열의 길이 - 현재 위치)를 더한다.

3. 계획 검증
그리디 알고리즘의 정당성을 증명하자면,

1) 탐욕적 선택속성 증명

 1. 가장 작은 값을 먼저 선택하지 않는(가장 작은 값부터 큰 값 순으로 정렬되어 있지 않은) 최적해가 존재함을 가정한다.
 2. 앞에 오는 값은 뒤 사람들의 총 소요시간에 모두 영향을 끼치므로, 더 큰 값이 앞에 올 경우 뒤 사람들의 총 소요시간이 작은 값이 왔을 때보다 커지게 된다.
 3. 따라서 가장 작은 값을 먼저 선택하지 않으면 반드시 전체 소요시간은 증가하게 된다.
 4. 따라서 인출에 걸리는 시간이 가장 적은 사람을 먼저 선택하는 것만이 최적해를 도출할 수 있다.

2) 최적 부분구조 증명
 첫 번째 사람을 선택후 나머지 사람들의 순서를 짜는 부분문제가 남는데, 이 때 또한 합한 시간을 최소화하는 같은 기준을 적용하면 전체에도 최적의 결과를 가져오므로 최적 부분구조는 자명하게 성립한다.

*/

int ATM_min(int N, vector<int> time) {
	int min = 0; // 최소값을 저장할 변수

	// 2. 정렬함수를 통해 배열 정렬
	sort(time.begin(), time.end());

	for (int i = 0; i < N; i++) {
		min += time[i] * (time.size() - i);
	}

	return min;
}

int main() {
	int N; // ATM에 줄 서있는 사람의 수
	
	int temp_time;
	vector<int> time; // 사람들이 인출에 걸리는 시간을 받을 벡터

	int min = 0; // 최소값을 저장할 변수

	cin >> N;

	// 1. 들어온 값 벡터에 받기
	for (int i = 0; i < N; i++) {
		cin >> temp_time;
		time.push_back(temp_time);
	}

	min = ATM_min(N, time);

	cout << min;
	return 0;
}